# I joined the #100DaysOfAlgorithm Challenge.

To join the Challenge read [Lets Join the #100DaysOfAlgorithm](https://ishansubedi.herokuapp.com/blog/7) and get started.

##Logs

### Day 0: January 20, 2017
1) **duplicate_encoder:**  It converts a string to a new string where each character in the new string is '(' if that character appears only once in the original string, or ')' if that character appears more than once in the original string. 

2) **digital_root:** A digital root is the recursive sum of all the digits in a number. Given n, it takes the sum of the digits of n. If that value has two digits, it continues reducing in this way until a single-digit number is produced. This is only applicable to the natural numbers.

### Day 1: January 21, 2017

3) **pairity_outliner:**  You are given an array (which will have a length of at least 3, but could be very large) containing integers. The array is either entirely comprised of odd integers or entirely comprised of even integers except for a single integer N. It contains a method that takes the array as an argument and returns N.

### Day 2: January 22, 2017

4) **exes_and_ohs:**  Checks to see if a string has the same amount of 'x's and 'o's. The method will return a boolean and is case insensitive. The string can contain any char.

### Day 3: January 23, 2017

5) **trailling_zero:** Finds to total number of trailling zeros in the factorial of a supplied number. 

### Day 4: January 24, 2017

6) **next_big_number:** A function that takes a positive integer number and returns the next bigger number formed by the same digits. If no bigger number can be composed using those digits, it return -1. Phew, it was tough.

### Day 5: January 25, 2017

7) **perfect_power:** Checks if the number is perfect power and returns the corresponding pair i^j. It returns nil if the number is not a perfect power.

8) **to_camel_case:**  It converts dash/underscore delimited words into camel casing. For example : to_camel_case("the-stealth-warrior") retutns "theStealthWarrior"

### Day 6: January 26, 2017

9) **bits_battle:** A list of positive integers is given. The odd numbers from the list will fight using their 1 bits from their binary representation, while the even numbers will fight using their 0 bits. This way the function returns the winner or a tie.

### Day 7: January 27, 2017

10) **bits_war:** In addition to the 9th challenge, the war has expanded and become dirtier and meaner; both even and odd numbers will fight with their pointy 1s. And negative integers are coming into play as well. 

### Day 8: January 28, 2017

11) **bits_war:** It takes any non-negative integer as a argument and returns it with it's digits in descending order.

12) **largest_5_digit:** It returns the largest five digit sequence of number found within the number given. The number will be passed in as a string of only digits. It should return a five digit integer. 

13) **palindrome_chain_length:** It takes a positive number and returns the number of special steps needed to obtain a palindrome. The special step is: "reverse the digits, and add to the original number".

### Day 9: January 29, 2017

14) **hashtag_generator:** It takes a string and does the following:  
-If the final result is longer than 140 chars it returns false.  
-If the input is a empty string it returns false.  
-It starts with a hashtag (#).  
-All words have their first letter capitalized.  
for example input of " hello world " => "#HelloWorld"  

### Day 10: January 30, 2017

15) **first_non_repeating_letter:** It takes a string input, and returns the first character that is not repeated anywhere in the string. In addition, upper and lowercase letters are considered the same character, but the function returns the correct case for the initial letter. If a string contains all repeating characters, it returns the empty string ("").

### Day 11: January 31, 2017

16) **count_smiley:** Given an array (arr) as an argument the function countSmileys returns the total number of smiling faces. The rules for smiling faces are :  
-Each smiley face must contain a valid pair of eyes. Eyes can be marked as : or ;  
-A smiley face can have a nose but it does not have to. Valid characters for a nose are - or ~  
-Every smiling face must have a smiling mouth that should be marked with either ) or D. 

17) **break_camelCase:** The function will break up camel casing, using a space between words. For example 'camelCasing' returns 'camel Casing'

### Day 12: February 1, 2017

18) **creditCard_mask:** The function maskify, changes all but the last four characters into '#'. For example '4556364607935616' returns '############5616'

### Day 13: February 2, 2017

19) **pileOfCubes:** We pass a variable m as an argument and the function will return n if it exists and -1 if it doesn't exist such that m = n^3 + (n-1)^3 + ... + 1^3. Basically, m represents total voloume of building and n represents total pile of cubes placed one over another to form the building.

